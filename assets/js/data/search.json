[ { "title": "Solaris Package creation with relocation support", "url": "/posts/solaris-packaging/", "categories": "blogs, tech", "tags": "solaris", "date": "2013-03-13 08:00:00 +0530", "snippet": "Creating a Solaris package to ship your application to your customer or user. Making it relocatable so the user can choose to install at any location.BackgroundI was working on a application which ...", "content": "Creating a Solaris package to ship your application to your customer or user. Making it relocatable so the user can choose to install at any location.BackgroundI was working on a application which was ready to be shipped to the customer. We wanted to ship the application in such a way that its easier for the user to install. We started evaluating different ways to ship the application. After experiencing the Portable applications on Windows and the zip/dmg way of App delievery in macOS (formally OS X), the first option which came to everybody’s mind was to create a zip of our application.The advantage of zip was that the user was able to download the zip from our website and extract it on their machine to install the application.As our application development progressed we realized that zipping the application with a README file is not enough. Testers were frequently missing some or the other step and running into installation failures. We decided to add a small script which would automate the process of installing the application. It worked great till we had to work with Testers who were not familiar with installation process.Finally we decided to create a Solaris Package so the Testers and eventually our Customer/User could easily install the application and find help onliine. Solaris Packages were meeting all our requirements like it has a dependency management, it can be easily installed/uninstalled and it has a help system. Apart from this it gave us the freedom of adding various scripts to handle the installation process at different stages.Creating Solaris PackageSolaris Packages can be created in 4 simple steps listed below: Create working space where we will be creating our package. mkdir /tmp/myapp &amp;&amp; cd /tmp/myappexport MYAPP_PACKAGE_DIR=/tmp/myapp Create a pkginfo file for information about your package. Check here for more info on pkginfo file. PKG=&lt;pkg&gt;NAME=&lt;pkg&gt;VERSION=&lt;ver&gt;ARCH=&lt;arch&gt;CLASSES=noneCATEGORY=applicationVENDOR=&lt;vendor&gt;PSTAMP=`date`EMAIL=noreply@bikramjs.inBASEDIR=&lt;path&gt; Now lets create all the scripts which we will help us automate various steps during installation. # Copy all your scripts to some temp dircat /path/src/request &gt; ${MYAPP_PACKAGE_DIR}/requestcat /path/src/preinstall &gt; ${MYAPP_PACKAGE_DIR}/preinstallcat /path/src/postinstall &gt; ${MYAPP_PACKAGE_DIR}/postinstallcat /path/src/checkinstall &gt; ${MYAPP_PACKAGE_DIR}/checkinstallcat /path/src/preremove &gt; ${MYAPP_PACKAGE_DIR}/preremovecat /path/src/postremove &gt; ${MYAPP_PACKAGE_DIR}/postremovecat /path/src/copyright &gt; ${MYAPP_PACKAGE_DIR}/copyright #for copyright messagecat /path/src/depend &gt; ${MYAPP_PACKAGE_DIR}/depend #for adding package names which are required for your package in format of &lt;type&gt; &lt;pkg.abbr&gt; &lt;name&gt; There are mainly 6 scripts that you can add to your package. There are some other scripts also which are used for patching. Following is brief explaination about those scripts: request: To prompt user for input. This script will not be executed if the package is already installed with instance=overwrite in /var/sadm/install/admin/default file checkinstall: Used to check whether the package is already installed or the system meets the requirements of package or to configure the installation of your package by setting environment for other scripts. preinstall: Used to configure installation according to the environment set in checkinstall script. postinstall: Used to configure installation after the installation has happened. preremove: Used to execute some pre un-installation commands like removing the new files created by the package which were not part of the package supplied. postremove: Used to execute full cleanup and other system commands like ldconfig to remove the broken links left by the package removal. Create a Prototype file for your package to include the files which you want to ship. i pkginfoi preinstalli postinstalli checkinstalli requesti preremovei postremovei copyrighti depend i in front of all the scripts indicate that its a installation script. Please check documentation here for more info. Now we have a basic Prototype file with our scripts, copyright message and dependencies. Next we will add our application to the Prototype file: # myapp in the command below is the name of the sub folder which will contain all my files.pkgproto /path/src/dist=/myapp &gt;&gt; ${MYAPP_PACKAGE_DIR}/Prototype Create the installable package using pkgmk. Check here for more information. pkgmk -o -r / -d ${MYAPP_PACKAGE_DIR} -f ${MYAPP_PACKAGE_DIR}/Prototype Previous step creates the package in a directory which is not suitable for shiping or downloading from a website. Now we need to translate the package from directory to a data stream file. Check here for more info on pkgtrans. pkgtrans -s `pwd` ${MYAPP_PACKAGE_DIR}/myapp.pkg myapp You can use any temporary directory just replace /tmp with your choice. You can set the file permissions before creating a prototype file. You can use your custom prototype file for file mappings pointing to files in specific directory. for e.g. : i pkginfo=/home/user/mysrc/pkginfo. You can use your own custom prototype file to define the file permissions also. You can use -g flag in pkgtrans command to sign the packages to build trust among your users. Making package relocatableSo far we have see how to create a package on Solaris. Now in order to make it relocatable we need to run few extra steps during the packing process.Steps would remain same till Prototype file generation. After the Prototype file is generated we need to update our Prototype to tell it that its a relocatable package and user should be able to install the package at any location they want. Lets make the package relocateable sed -i \"s:/myapp:\\$BASEDIR/:g\" ${MYAPP_PACKAGE_DIR}/Prototype # $BASEDIR variable will make sure that package becomes relocateable Now lets create the pkg using pkgmk command with a value pointing to our package locally. pkgmk -o -r / -d ${MYAPP_PACKAGE_DIR} -f ${MYAPP_PACKAGE_DIR}/Prototype BASEDIR=/path/src/dist # BASEDIR here is a varaible Now we can use the pkgtrans command to convert it to a single file for easy distribution. pkgtrans -s `pwd` ${MYAPP_PACKAGE_DIR}/myapp.pkg myapp TestingTo test the package, you can install it on a Solaris machine and use following command to verify if the relocation support we added is working or not. Check here for all supported options in pkgadd.pkgadd –R /opt/installed_myapp myapp.pkgls -l /opt/installed_myapp/bin/myapp" }, { "title": "Building gcc 4.1.2 on Solaris 10", "url": "/posts/building-gcc-on-solaris/", "categories": "blogs, tech", "tags": "solaris, gcc", "date": "2013-03-13 08:00:00 +0530", "snippet": "Compiling gcc 4.1.2 on Solaris to over come compilation and linking issues faced during porting my C++ application from RHEL.BackgroundI was working on porting an C++ Application from RHEL to Solar...", "content": "Compiling gcc 4.1.2 on Solaris to over come compilation and linking issues faced during porting my C++ application from RHEL.BackgroundI was working on porting an C++ Application from RHEL to Solaris 10. I was getting too many compile time errors when recompiling the application on Solaris. Initially I tried fixing those errors without thinking that language also has progressed and we might need a new compiler. After a few days finally I started comparing the build environment and closed on compiler version being different.Upgrading CompilerInitially like anybody else, we took the latest version of gcc available on Solaris 10 and tried compiling my code. It never worked out. I realized that language standard have progressed much further and gcc use to throw new errors which would have taken long time for me to fix.pkg install gcc-45Compiling the CompilerAfter my failed attempt to compile my code using latest gcc compiler, I started searching for pre-built packages for gcc 4.1.2 on Solaris 10 without any luck.Finally we made a decision to compile the compiler ourself. I immediately downloaded gcc 4.1.2 from gcc’s website. I saw that there is a configure script and Makefile. Looking at the documentation I ran configure script with bare minimum options followed by gmake. The compiler worked and I was able to compile my code. The testing cycle could start now.pkg install gcc-3cd gcc_source_dirmkdir objdir &amp;&amp; cd objdir../configure --enable-languages=c,c++gmakegmake installNext day, while reviewing my colleague’s code I found that there is a security issue with the compiler which we compiled. All the private methods were accessible in our library and anybody could call those methods.nm /path/to/library.a...00000000000021b0 T CLIF_arg_double00000000000021e0 T CLIF_arg_func0000000000002190 T CLIF_arg_int0000000000002140 T CLIF_arg_string00000000000021a0 T CLIF_arg_uint00000000000021c0 T CLIF_call_func0000000000001600 T CLIF_current_help0000000000001670 T CLIF_parse0000000000000fb0 T CLIF_print_arguments0000000000000e00 T CLIF_print_options0000000000001100 T CLIF_print_usage0000000000002180 T CLIF_set_double00000000000020e0 T CLIF_set_flag0000000000002160 T CLIF_set_int0000000000002120 T CLIF_set_string0000000000002170 T CLIF_set_uint0000000000002100 T CLIF_unset_flag00000000000020a0 T CLIF_version_handler...Upon debugging the library, I found that all the public/private functions which we wrote had a T denoting that the functions are public. We again started compiling gcc with different arguments. After many attempts there was a time when all of the functions even the public ones became private.Now many iterations later we were able to compile gcc for our use case using following steps: Install gcc 3.4.3pkg install gcc-3 By default Solaris 10 comes with gcc 3.4.3 and binutils 2.15. We need to compile binutils 2.18 in order gcc compiled correctly. Prepare the shell for compiling gcc:# Use ksh shellexport CONFIG_SHELL=/usr/bin/ksh# Copy/Create links to all gnu tools into one directory and remember to remove letter 'g' from the prefix of the name of executable.export PATH=/Mytools/binutils_2_18/bin:/gnutools:/sbin:/bin:/usr/bin:/usr/ccs/bin:/usr/sfw/binexport CC=\"/usr/sfw/bin/gcc -fPIC\"export CXX=\"/usr/sfw/bin/g++ -fPIC\" /Mytools/binutils_2_18 is the location where binutils 2.18 is installed. /gnutools is the location where gnu tools like gmake, gawk, gsed and gmake etc are symlinked without the g prefix. Build:cd gcc_source_dirmkdir objdir &amp;&amp; cd objdir../configure --with-gnu-as --with-as=/binutils_2_18/bin/as --with-gnu-ld --with-ld=/binutils_2_18/bin/ld --prefix=$PREFIX --enable-threads=posix --enable-checking=release --with-system-zlib --enable-shared --disable-symvers --enable-languages=c,c++gmake #referring to gnu makegmake install $PREFIX is the location where you want to install gcc. It should be writable by your user.LearningsI learned that compiling a compiler without a compiler is kind of fun. Following are the things I learned: gcc built a basic compiler before actually compiling the code. gcc configure script has so many flags which can cause security issues in the output binary like the one time when I acciedently made all the functions public." } ]
